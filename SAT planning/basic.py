""" SAT PLANNING"""
#....ALL the methods are done by me here except encode method which was given already as part of the assignment.
""" Student Details

    Student Name:
    Student ID:
    Email:
    Date:
"""


""" This file contains the methods you need to implement to create a basic
    (non-split) encoding of planning as SAT.

    You can work your way through the exercises below to build up the encoding.

    We strongly recommend that you test as you go on some of the smaller
    benchmark problems.

    Here is a simple example to run the problem on the smallest Miconics
    instance:

    python3 planner.py benchmarks/miconic/domain.pddl benchmarks/miconic/problem01.pddl miconic1 4

    You might want to implement the plan extraction method after you implement
    the method to create the CNF variables. You will then be able to generate
    (probably incorrect) plans as you add more constraints.

    To test the fluent mutex axioms and reachable action axioms you will need
    to turn on the plangraph computation "-p true".

    Remember, it is relatively easy to figure out where you have gone wrong if
    the SAT solver finds invalid plans. For example if the plan validator
    indicates that an action has an unsatisfied precondition, then there is
    probably something wrong with your precondition clauses or your frame
    axioms. However, if the SAT instance is unsatisfiable, then you will likely
    have to start removing constraints to figure out where you went wrong.

    To help you debug your encoding, you can use the argument "-d true" to
    write an annotated CNF file with the clauses you are generating. Warning:
    Looking through this for large problems will be nearly impossible, so test
    on the small instances.

    Sometimes SAT encodings of planning problems can end up BIG because there
    are just so many actions. Either use the argument "-r true" or clear out
    your tmp_files directory periodically and manually.

    This system is designed to run on either Linux or Mac machines. This is
    unavoidable because we need to call and run external grounding and SAT
    solving programs.

    This software will NOT work on Windows. We suggest using a virtual machine,
    or working in the labs if you do not have a linux installation.
"""

from typing import Dict, List, Tuple

from strips_problem import Action, Proposition
from utilities import encoding_error_code

from .encoding_base import Encoding, EncodingException

encoding_class = 'BasicEncoding'


class BasicEncoding(Encoding):
    """ A simple basic encoding along the lines of SatPlan06 with full frame
        axioms.

        Variables and clauses are created once
    """

################################################################################
#                You need to implement the following methods                   #
################################################################################

    def make_variables(self, horizon: int) -> None:
        """ Make the variables (state and action fluents) for the problem.

            Exercise 1 - 5 Marks

            The method self.new_cnf_code(step, name, object) will return an int
            representing a new CNF variable for you to use in your encoding.

            Let k be the horizon which is passed as a parameter. Use the above
            method to make one variable for each Proposition at each step 0..k
            and one variable for each Action at each step from 0..k-1.

            Access the actions and propositions from the lists
            self.problem.actions and self.problem.propositions.

            Use str(proposition) to get name of a proposition and str(action)
            to get the name of an action when calling self.new_cnf_code.

            For object, you should just pass either the Proposition or Action
            object.

            So, self.new_cnf_code(4, str(a), a) will create a new variable and
            return a code (an int) representing the CNF variable for action a,
            at step 4.

            Since you will need to use these variables to make your constraints
            later, you should store them in self.action_fluent_codes and
            self.proposition_fluent_codes.

            These should map each (Action, step) pair and each (Proposition,
            step) pair to the appropriate code.

            Once you have made the variables, you can get the step, name, and
            object (Action or Proposition) with the following:
               - self.cnf_code_steps[code]
               - self.cnf_code_names[code]
               - self.cnf_code_objects[code]

            You shouldn't need to use these until you come to extract the plan
            generated by the SAT solver, but they might be useful for
            debugging!
        """
        self.action_fluent_codes: Dict[Tuple[Action, int], int] = {}
        self.proposition_fluent_codes: Dict[Tuple[Proposition, int], int] = {}
        """ -----------------------EDIT AFTER THIS PART------------------------------"""

        # >python planner.py benchmarks/miconic/domain.pddl benchmarks/miconic/problem01.pddl miconic1 4
        # itearting over propositions to create its cnf code
        for i in range(horizon+1):
            for name in self.problem.propositions:
                self.new_cnf_code(i,str(name),name)

        # itearting over actions to create its cnf code
        for i in range(horizon):
            for name in self.problem.actions:
                self.new_cnf_code(i,str(name),name)

        # To add key ,value pair for proposition and action fluent codes which will be used in every function
        for key in self.cnf_code_objects.keys():
            if self.cnf_code_objects[key] in self.problem.propositions:
                self.proposition_fluent_codes[(self.cnf_code_objects[key],self.cnf_code_steps[key])]=key
            elif self.cnf_code_objects[key] in self.problem.actions:
                self.action_fluent_codes[(self.cnf_code_objects[key],self.cnf_code_steps[key])]=key
        """ YOUR CODE HERE """

    def make_initial_state_and_goal_axioms(self, horizon: int) -> None:
        """ Make clauses representing the initial state and goal.

            Exercise 2 - 5 Marks

            In this method, add clauses to the encoding which ensure that the
            initial state of the problem holds at step 0. The Propositions
            which must be true are in self.problem.pos_initial_state and the
            Propositions which must be false are in
            self.problem.neg_initial_state.

            Every Proposition in the problem will be in one of these two sets.

            Also add clauses which ensure that the goal holds at the horizon.
            Similarly to the start state, the goal clauses are in
            self.problem.goal.

            Not every Proposition will be in the goal. The truth values of
            other Propositions should remain unconstrained.

            A clause is a list of positive or negative integers (representing
            positive and negative literals) using the variables you created
            for Q1. Get the variables from self.proposition_fluent_codes).

            Every clause has a type, which is represented by a string.

            Add clauses to the encoding with self.add_clause(clause,
            clause_type).

            The type of the start state clauses should be "start" and the type
            of the goal clauses should be "goal".
        """
        #creating lists to take care of adding double clauses.
        added_pos=[]
        added_neg=[]
        added_goal=[]

        # iterating over positive initial states avaialable
        for p_state in self.problem.pos_initial_state:
            if p_state in added_pos:
                continue
            value=self.proposition_fluent_codes[(p_state,0)]
            clause=[value]
            added_pos.append(clause)
            self.add_clause(clause,'start')
        # iterating over negative initial states avaialable
        for p_state in self.problem.neg_initial_state:
            if p_state in added_neg:
                continue
            value=self.proposition_fluent_codes[(p_state,0)]
            clause=[int(0-value)]
            added_neg.append(clause)
            self.add_clause(clause,'start')
        #iterating over goal states
        for p_state in self.problem.goal:
            if p_state in added_goal:
                continue
            value = self.proposition_fluent_codes[(p_state, horizon)]
            clause = [value]
            added_goal.append(clause)
            self.add_clause(clause, 'goal')

        """ *** YOUR CODE HERE *** """

    def make_precondition_and_effect_axioms(self, horizon: int) -> None:
        """ Make clauses representing action preconditions and effects.

            Exercise 3 - 5 Marks

            In this method, add clauses to the encoding which ensure that
            If an action is executed at step t = 0..k-1:
                - its preconditions hold at step t and
                - its effects hold at step t+1.
                    (No action will both add and delete the same proposition)

            Add clauses with self.add_clause(clause, clause_type).

            In your clauses use the variables from self.action_fluent_codes and
            self.proposition_fluent_codes.

            Precondition clauses have the type 'pre' and effect clauses have the
            type "eff".

            Don't forget to look in strips_problem.py for the data structures
            you need to use!
        """
        # iterating over actions and its values to gets corresponding neg_effects,pos
        for key,value in self.action_fluent_codes.items():
            # separating precondtiion, pos_Effects and neg_effects to iterate over them separately
            preconditions=key[0].preconditions
            pos_effects=key[0].pos_effects
            neg_effects=key[0].neg_effects
            invalid=False
            #------ This is to wedge out the invalid actions which are adding and deleting same propotions
            for p in pos_effects:
                if p in neg_effects:
                    invalid=True
                    break
            if invalid:
                continue
            #iterating over preconditions of the actions
            for p in preconditions:
                v1=self.proposition_fluent_codes[(p,key[1])]
                c1=[int(0-value),v1]
                self.add_clause(c1,'pre')
            # iterating over positive effects of the actions to add it into clause
            for p_e in pos_effects:
                v2 = self.proposition_fluent_codes[(p_e, (key[1] + 1))]
                c2=[int(0-value),v2]
                self.add_clause(c2,'eff')
            # iterating over negative effects of the actions to add it into clause
            for n_e in neg_effects:
                v3=self.proposition_fluent_codes[(n_e,(key[1]+1))]
                c3=[(0-value),(0-v3)]
                self.add_clause(c3,'eff')
        """ *** YOUR CODE HERE *** """

    def make_explanatory_frame_axioms(self, horizon: int) -> None:
        """ Make clauses representing explanatory frame axioms.

            Exercise 4 - 10 Marks

            In this method, add clauses to the encoding which ensure that
            If a proposition p is true at step t = 1..k:
                - either p is true at t-1 or
                - an action is executed at t-1 which added p.

            If a proposition p is false at step t = 1..k:
                - either p is false at t-1 or
                - an action is executed at t-1 which deletes p

            Add clauses with self.add_clause(clause, clause_type).

            In your clauses use the variables from self.action_fluent_codes
            and self.proposition_fluent_codes.

            These clauses have the type "frame".

            To make this process easier, Proposition objects have lists of
            the actions
            which have them as positive and negative and effects.
        """
        # >python planner.py benchmarks/miconic/domain.pddl benchmarks/miconic/problem01.pddl miconic1 4
        # creating lists to make sure not to add duplicate clauses
        added=[]
        added_pos=[]
        added_neg=[]
        # iterating over propositions
        for propositions in self.problem.propositions:
            for i in range(horizon+1):
                if (i+1)<=horizon:
                    actions_pos = [self.action_fluent_codes[(x,i)] for x in propositions.pos_effects]
                    p_at_t=self.proposition_fluent_codes[(propositions,i)]
                    p_at_t_plus1 = self.proposition_fluent_codes[(propositions, i+1)]
                    clause1=[p_at_t,int(0-p_at_t_plus1)]+actions_pos
                    if clause1 not in added_pos and len(actions_pos)>0:
                        added_pos.append(clause1)
                        self.add_clause(clause1, 'frame')

                    actions_neg = []
                    actions_neg = [self.action_fluent_codes[(x, i)] for x in propositions.neg_effects]
                    p_at_t_false = self.proposition_fluent_codes[(propositions, i)]
                    p_at_t_plus1_false = self.proposition_fluent_codes[(propositions, int(i + 1))]
                    clause2 = [int(0 - p_at_t_false), p_at_t_plus1_false] + actions_neg
                    if clause2 not in added_neg and len(actions_neg) > 0:
                        added_neg.append(clause2)
                        self.add_clause(clause2, 'frame')
        """ *** YOUR CODE HERE *** """

    def make_serial_mutex_axioms(self, horizon: int) -> None:
        """ Make clauses representing serial mutex.

            Exercise 5 - 10 Marks

            In this method, add clauses to the encoding which ensure that at
            most one action is executed at each step t = 0..k-1. (It could be
            the case that no actions are executed at some steps).

            To get full marks, you should add as few clauses as possible.
            Notice that actions with conflicting effects are already prevented
            from being executed in parallel.

            Add clauses with self.add_clause(clause, clause_type).

            In your clauses use the variables from self.action_fluent_codes.

            These clauses have the type "mutex".
        """

        #python planner.py benchmarks/miconic/domain.pddl benchmarks/miconic/problem01.pddl miconic1 4 -x serial
        # to check for duplicate clause
        added=[]
        for a_key,a_value in self.action_fluent_codes.items():

            for a_dash_key,a_dash_value in self.action_fluent_codes.items():
                # Below is to get rid of same action pairs
                if a_key[0]==a_dash_key[0]:
                    continue
                brea = False
                # To check  if they have conflicting effect then they are invalid actions
                for eff1 in a_key[0].pos_effects:
                    if eff1 in a_dash_key[0].neg_effects:
                        brea = True

                for eff1 in a_key[0].neg_effects:
                    if eff1 in a_dash_key[0].pos_effects:
                        brea = True

                if brea:
                    continue
                # ------------ Till here its checking if inconsistent effects-----------
                if a_key[0]!=a_dash_key[0] and a_key[1]==a_dash_key[1]:

                    a=0-a_value
                    b=0-a_dash_value
                    clause=[a,b]
                    # To make sure duplicate values are not getting added in clauses.
                    if clause in added:
                        continue
                    added.append(clause)
                    a=clause
                    added.append(a.reverse())

                    self.add_clause(clause,'mutex')
        """ *** YOUR CODE HERE *** """

    def make_interference_mutex_axioms(self, horizon: int) -> None:
        """ Make clauses preventing interfering actions from being executed in parallel.

            Exercise 6 - 10 Marks

            In this method, add clauses to the encoding which ensure that two
            actions cannot be executed in parallel at a step t = 0..k-1 if they
            interfere.

            Two actions a1 and a2 interfere if there is a Proposition p such
            that p in EFF-(a1) and p in PRE(a2).

            To get full marks, you should not add clauses for interfering
            actions if their parallel execution is already prevented by
            conflict due to effect clauses. Also, careful not to add duplicate
            clauses!

            If you find your encoding time to be slow, it might be due to an
            inefficient implementation of this function. As a hint to make it
            faster, make use of the `neg_effects` and `preconditions`
            attributes stored in Proposition objects, instead of the
            `neg_effects` and `preconditions` attributes in Action objects.

            Add clauses with self.add_clause(clause, clause_type).

            In your clauses use the variables from self.action_fluent_codes.

            These clauses have the type "mutex".
        """
        added=[]
# since self.problem.proposition contains all the proposition and propostion's neg_effects is a list of actions which
        # makes it negative and same for pos and precondition so on that basis using this logic also to make it more
        # effective to take less time.
        for p1 in self.problem.propositions:
            for act in p1.neg_effects:
                for act2 in p1.preconditions:
                    # To check if action pairs are inconsiste, or invalid actions
                    if act2 in p1.pos_effects or act in p1.pos_effects or act == act2 or act==None or act2==None:
                        continue
                    inconsistent=False
                    # below part is to check for inconsistent effects so as to not add those actions
                    for p in act2.pos_effects:
                        if p in act.neg_effects:
                            inconsistent=True
                    for p in act.pos_effects:
                        if p in act2.neg_effects:
                            inconsistent=True
                    if inconsistent:
                        continue
                    if not act==act2:
                        limit=0

                        # if type(self.problem.action_first_step)==dict:
                        #     a1=self.problem.action_first_step[act]
                        #     a12 = self.problem.action_first_step[act2]
                        #     if a1<a12:
                        #         limit=a12
                        #     if a1>a12:
                        #         limit=a1
                        #     elif a1==a12:
                        #         limit=a1
                        # To reduce number of clauses by checking if action's precondtion is in initial state
                        # then they can be added since initial step otherwise we can skip that
                        if limit==0:
                            okay=False
                            for pre in act.preconditions:
                                if pre not in self.problem.pos_initial_state:
                                    okay=False
                                else:
                                    okay=True
                            for pre in act2.preconditions:
                                if pre not in self.problem.pos_initial_state:
                                    okay=False
                                else:
                                    okay=True

                            if not okay:
                                limit=1

                        for i in range(limit,horizon):
                            value1 = self.action_fluent_codes[(act, i)]
                            value2 = self.action_fluent_codes[(act2, i)]
                            clause = [int(0 - value1), int(0 - value2)]
                            # checking for duplicate clauses
                            if clause in added:
                                continue
                            self.add_clause(clause, 'mutex')
                            added.append(clause)
                            a=clause
                            a.reverse()
                            added.append(a)

        """ *** YOUR CODE HERE *** """

    def make_reachable_action_axioms(self, horizon: int) -> None:
        """ Make unit clauses preventing actions from being executed before they
            become available in the plangraph.

            Exercise 7 - 5 Marks

            In this method, add clauses to the encoding which ensure that an
            action is not executed before the first step it is available in
            self.problem.action_first_step.

            For example, if self.problem.action_first_step[action1] == 5, then
            you would introduce clauses stopping action1 from being executed at
            steps 0..4.

            These clauses are not required for correctness, but may improve
            performance.

            Add clauses with self.add_clause(clause, clause_type).

            In your clauses use the variables from self.action_fluent_codes.

            These clauses have the type "reach".
        """

        """ *** YOUR CODE HERE *** """

# python3 planner.py benchmarks/logistics/domain.pddl benchmarks/logistics/problem03.pddl logistic03 10 -e basic -p false
        clause=[]
        for action in self.problem.actions:
            limit=self.problem.action_first_step[action]
            if limit>horizon:
                limit=horizon
            # iterating till limit of the action's first step
            for i in range(limit):
                clause.clear()
                if (action,i) in self.action_fluent_codes.keys():
                    step=self.action_fluent_codes[(action,i)]
                    clause.append(int(0-step))
                    self.add_clause(clause,'reach')

    def make_fluent_mutex_axioms(self, horizon: int) -> None:
        """ Make clauses representing fluent mutex as computed by the plangraph.

            Exercise 8 - 5 Marks

            In this method, add clauses to the encoding which ensure that pairs
            of propositions cannot both be true at the same time. These
            constraints are computed when the plangraph is generated.

            These clauses are not required for correctness, but usually make
            planning faster by causing the SAT solver to backtrack earlier.

            The dictionary self.problem.fluent_mutex maps integers representing
            planning steps to lists of proposition mutex relationships at each
            step from 1...n, where n is the step that the plangraph levels off.
            Note that the dictionary doesn't contain steps greater than n,
            because the relationships at step n also hold for every step
            greater than n. Thus you can get those mutex relationships by
            querying the dictionary with step n.

            You can get n by getting the largest key in
            self.problem.fluent_mutex maps.

            It is possible that the current horizon is less than n. In this
            case, mutex relationships larger than the horizon should, of
            course, be ignored.

            As the initial state clauses completely determine the truth values
            of fluents at step 0, there is no need for fluent mutex clauses
            there.

            Each list of mutex relationships in self.problem.fluent_mutex will
            be as follows:

              [(f1, f2), ....]

            Say, we have (f1, f2), then there should be a clause [-f1, -f2]
            (obviously substituting the appropriate CNF codes for f1 and f2,
            depending on the step.

            Add clauses with self.add_clause(clause, clause_type).

            In your clauses use the variables from
            self.proposition_fluent_codes.

            These clauses have the type "fmutex".
        """

        """ *** YOUR CODE HERE *** """

        for keys,values in self.problem.fluent_mutex.items():
            if keys>horizon:
                break

            for li in values:
                li1=self.proposition_fluent_codes[(li[0],keys)]
                li2=self.proposition_fluent_codes[(li[1],keys)]
                clause=[int(0-li1),int(0-li2)]
                self.add_clause(clause,'fmutex')


    def build_plan(self, horizon: int) -> None:
        """Build a plan from the true variables in a satisfying valuation found
           by the SAT solver.

           Exercise 9 - 5 marks

           self.true_vars is a set with the codes of the CNF variables which the
           SAT solver has set to true in the satisfying valuation it found.

           You can get the step, name, and object (Action/Proposition) of each variable
           (state or action fluent) with:
               - self.cnf_code_steps[code]
               - self.cnf_code_names[code]
               - self.cnf_code_objects[code]

           You can check if an object is an Action or Proposition with
               - isinstance(obj, Action) and
               - isinstance(obj, Proposition)

           You should add the plan to self.plan, which has the structure
           [action_list, action_list, ...].

           For each step t = 0..k-1, it has a (possibly empty) list of the
           actions which were executed at that step.

           So, if we have a0 and a1 at step 0 and a2 at step 2, then self.plan
           will be:

               [[a0, a1], [], [a2]]

           where a0, a1, a2, etc. are Action objects (not just their names).

           The system will validate the plans you generate, so make sure you
           test your encodings on a number of different problems.
        """
        self.plan: List[List[Action]] = []
        """ *** YOUR CODE HERE *** """

        for true_Vars in self.true_vars:
            step=self.cnf_code_steps[true_Vars]
            obje=self.cnf_code_objects[true_Vars]

            if isinstance(obje,Action):
                obj=[]
                if len(self.plan)>step:
                    obj=self.plan[step]
                    # to remove the list which is there previously
                    self.plan.remove(obj)
                # to add the previous entry if theere is any in to list
                obj.append(obje)
                self.plan.insert(step,obj)


################################################################################
#                    Do not change the following method                        #
################################################################################

    def encode(self, horizon: int, exec_semantics: str, plangraph_constraints: str) -> None:
        """ Make an encoding of self.problem for the given horizon.

            For this encoding, we have broken this method up into a number
            of sub-methods that you need to implement.
        """

        self.make_variables(horizon)

        self.make_initial_state_and_goal_axioms(horizon)

        self.make_precondition_and_effect_axioms(horizon)

        self.make_explanatory_frame_axioms(horizon)

        if exec_semantics == "serial":
            self.make_serial_mutex_axioms(horizon)
        elif exec_semantics == "parallel":
            self.make_interference_mutex_axioms(horizon)
        else:
            assert False

        if self.problem.fluent_mutex is not None:
            # These constraints will only be included if the plangraph was computed
            if plangraph_constraints == "both":
                self.make_reachable_action_axioms(horizon)
                self.make_fluent_mutex_axioms(horizon)
            elif plangraph_constraints == "fmutex":
                self.make_fluent_mutex_axioms(horizon)
            elif plangraph_constraints == "reachable":
                self.make_reachable_action_axioms(horizon)
